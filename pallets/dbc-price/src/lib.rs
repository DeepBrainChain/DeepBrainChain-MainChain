#![cfg_attr(not(feature = "std"), no_std)]

use codec::{Decode, Encode};
use frame_support::{
    debug, decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult,
};
use frame_system::{
    ensure_none, ensure_root, ensure_signed,
    offchain::{
        AppCrypto, CreateSignedTransaction, SendSignedTransaction, SendUnsignedTransaction,
        SignedPayload, Signer, SigningTypes,
    },
};
use lite_json::json::JsonValue;
use sp_core::crypto::KeyTypeId;
use sp_runtime::{
    offchain::{http, Duration},
    RuntimeDebug,
};
use sp_std::str;
use sp_std::vec::Vec;

type URL = Vec<u8>;
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"dbc!");

pub mod crypto {
    use super::KEY_TYPE;
    use sp_core::sr25519::Signature as Sr25519Signature;
    use sp_runtime::{
        app_crypto::{app_crypto, sr25519},
        traits::Verify,
        MultiSignature, MultiSigner,
    };
    app_crypto!(sr25519, KEY_TYPE);

    pub struct TestAuthId;

    // implemented for dbc-price
    impl frame_system::offchain::AppCrypto<MultiSigner, MultiSignature> for TestAuthId {
        type RuntimeAppPublic = Public;
        type GenericSignature = sp_core::sr25519::Signature;
        type GenericPublic = sp_core::sr25519::Public;
    }

    // implemented for mock runtime in test
    impl frame_system::offchain::AppCrypto<<Sr25519Signature as Verify>::Signer, Sr25519Signature>
        for TestAuthId
    {
        type RuntimeAppPublic = Public;
        type GenericSignature = sp_core::sr25519::Signature;
        type GenericPublic = sp_core::sr25519::Public;
    }
}

#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug)]
pub struct Payload<Public> {
    price: u64,
    public: Public,
}

impl<T: SigningTypes> SignedPayload<T> for Payload<T::Public> {
    fn public(&self) -> T::Public {
        self.public.clone()
    }
}

pub trait Config: CreateSignedTransaction<Call<Self>> {
    type AuthorityId: AppCrypto<Self::Public, Self::Signature>;
    type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;
}

decl_event!(
    /// Events generated by the module.
    pub enum Event<T>
    where
        AccountId = <T as frame_system::Config>::AccountId,
    {
        /// Event generated when new price is accepted to contribute to the average.
        /// \[price, who\]
        NewPrice(u64, Option<AccountId>),
    }
);

decl_error! {
    pub enum Error for Module<T: Config> {
        NoLocalAcctForSigning,
        FetchPriceFailed,
        OffchainUnsignedTxSignedPayloadError,
    }
}

decl_storage! {
    trait Store for Module<T: Config> as ExampleOffchainWorker {
        Prices get(fn prices): Vec<u64>;
        PriceURL get(fn price_url) config(): URL = "https://min-api.cryptocompare.com/data/price?fsym=DBC&tsyms=USD".as_bytes().to_vec();
        NextUnsignedAt get(fn next_unsigned_at): T::BlockNumber;
    }
}

decl_module! {
    pub struct Module<T: Config> for enum Call where origin: T::Origin {
        fn deposit_event() = default;

        #[weight = 0]
        pub fn submit_price_signed(origin, price: u64) -> DispatchResult {
            let who = ensure_signed(origin)?;
            Self::add_price(Some(who), price);
            Ok(())
        }

        #[weight = 0]
        pub fn submit_price_unsigned(origin, price: u64) -> DispatchResult {
            let _ = ensure_none(origin)?;
            Self::add_price(None, price);

            Ok(())
        }

        #[weight = 0]
        pub fn submit_price_unsigned_with_signed_payload(origin, payload: Payload<T::Public>,
            _signature: T::Signature) -> DispatchResult
        {
            let _ = ensure_none(origin)?;
            let Payload {price, public} = payload;
            debug::info!("submit price unsigned with signed payload: ({}, {:?})", price, public);

            Self::add_price(None, price);
            Ok(())
        }

        #[weight = 0]
        pub fn set_price_url(origin, new_url: URL) -> DispatchResult {
            ensure_root(origin)?;
            PriceURL::put(new_url);
            Ok(())
        }

        fn offchain_worker(block_number: T::BlockNumber) {
            debug::native::info!("Hello world from offchain worker!");

            let average: Option<u64> = Self::average_price();
            debug::debug!("Current price: {:?}", average);

            // let result = Self::fetch_price_and_send_signed();
            let result = Self::fetch_price_and_send_unsigned_tx_with_signed_payload();

            if let Err(e) = result {
                debug::error!("offchain_worker error: {:?}", e);
            }
        }
    }
}

impl<T: Config> Module<T> {
    fn fetch_price_and_send_signed() -> Result<(), &'static str> {
        let signer = Signer::<T, T::AuthorityId>::all_accounts();
        if !signer.can_sign() {
            return Err(
                "No local accounts available. Consider adding one via `author_insertKey` RPC.",
            )?;
        }

        let price = Self::fetch_price().map_err(|_| "Failed to fetch price")?;

        let results = signer.send_signed_transaction(|_account| Call::submit_price_signed(price));

        for (acc, res) in &results {
            match res {
                Ok(()) => debug::info!("[{:?}] Submitted price of {} cents", acc.id, price),
                Err(e) => debug::error!("[{:?}] Failed to submit transaction: {:?}", acc.id, e),
            }
        }

        Ok(())
    }

    fn fetch_price_and_send_unsigned_tx_with_signed_payload() -> Result<(), Error<T>> {
        let signer = Signer::<T, T::AuthorityId>::any_account();
        if !signer.can_sign() {
            return Err(<Error<T>>::NoLocalAcctForSigning);
        }

        let price = Self::fetch_price().map_err(|_| <Error<T>>::FetchPriceFailed)?;

        if let Some((_, res)) = signer.send_unsigned_transaction(
            |acct| Payload {
                price,
                public: acct.public.clone(),
            },
            Call::submit_price_unsigned_with_signed_payload,
        ) {
            return res.map_err(|_| {
                debug::error!("Failed in offchain_unsigned_tx_signed_payload");
                <Error<T>>::OffchainUnsignedTxSignedPayloadError
            });
        }

        // The case of `None`: no account is available for sending
        debug::error!("No local account available");
        Err(<Error<T>>::NoLocalAcctForSigning)
    }

    fn fetch_price() -> Result<u64, http::Error> {
        let deadline = sp_io::offchain::timestamp().add(Duration::from_millis(4_000));

        let price_url = PriceURL::get();
        let price_url = str::from_utf8(&price_url).map_err(|_| http::Error::Unknown)?;

        let request = http::Request::get(price_url);

        let pending = request
            .deadline(deadline)
            .send()
            .map_err(|_| http::Error::IoError)?;

        let response = pending
            .try_wait(deadline)
            .map_err(|_| http::Error::DeadlineReached)??;
        // Let's check the status code before we proceed to reading the response.
        if response.code != 200 {
            debug::warn!("Unexpected status code: {}", response.code);
            return Err(http::Error::Unknown);
        }
        let body = response.body().collect::<Vec<u8>>();

        // Create a str slice from the body.
        let body_str = sp_std::str::from_utf8(&body).map_err(|_| {
            debug::warn!("No UTF8 body");
            http::Error::Unknown
        })?;

        let price = match Self::parse_price(body_str) {
            Some(price) => Ok(price),
            None => {
                debug::warn!("Unable to extract price from the response: {:?}", body_str);
                Err(http::Error::Unknown)
            }
        }?;

        debug::warn!("Got price: {} cents", price);

        Ok(price)
    }

    fn parse_price(price_str: &str) -> Option<u64> {
        let val = lite_json::parse_json(price_str);
        let price = val.ok().and_then(|v| match v {
            JsonValue::Object(obj) => {
                let mut chars = "USD".chars();
                obj.into_iter()
                    .find(|(k, _)| k.iter().all(|k| Some(*k) == chars.next()))
                    .and_then(|v| match v.1 {
                        JsonValue::Number(number) => Some(number),
                        _ => None,
                    })
            }
            _ => None,
        })?;

        // out = price.integer * 10**6 + price.fraction / 10**fraction_length * 10**6
        let fraction = price.fraction * 10_u64.pow(6) / 10_u64.pow(price.fraction_length);
        Some(price.integer as u64 * 1000_000 + fraction)
    }

    fn add_price(who: Option<T::AccountId>, price: u64) {
        debug::info!("Adding to the average: {}", price);
        Prices::mutate(|prices| {
            const MAX_LEN: usize = 64;
            if prices.len() < MAX_LEN {
                prices.push(price);
            } else {
                prices[price as usize % MAX_LEN] = price;
            }
        });

        let average = Self::average_price()
            .expect("The average is not empty, because it was just mutated; qed");

        debug::info!("Current average price is: {}", average);

        Self::deposit_event(RawEvent::NewPrice(price, who));
    }

    fn average_price() -> Option<u64> {
        let prices = Prices::get();
        if prices.is_empty() {
            None
        } else {
            Some(prices.iter().fold(0_u64, |a, b| a.saturating_add(*b)) / prices.len() as u64)
        }
    }
}
